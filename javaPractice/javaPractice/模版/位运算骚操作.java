package 模版;

//参考链接：https://labuladong.online/algo/frequency-interview/bitwise-operation/#%E5%AF%B9-2-%E7%9A%84%E5%B9%82%E5%8F%96%E6%A8%A1

//// 7. 判断两个数是否异号
//int x = -1, y = 2;
//boolean f = ((x ^ y) < 0); // true
//
//        int x = 3, y = 2;
//boolean f = ((x ^ y) < 0); // false


//当模数 m 是 2 的幂时，x % m 等价于 x & (m - 1)
//位运算 & 的效率比 % 高得多，所以这个技巧在性能敏感的场景中非常有用。
//比如说循环数组求模，如果数组长度是pow2,n的，那就可以用这个了
//简单说，& (arr.length - 1) 这个位运算能够替代 % arr.length 的模运算，性能会更好一些。
//那问题来了，现在是不断地 index++，你做到了循环遍历。但如果不断地 index--，还能做到环形数组的效果吗？
//答案是，如果你使用 % 求模的方式，那么当 index 小于 0 之后求模的结果也会出现负数，你需要特殊处理。但通过 & 与运算的方式，index 不会出现负数，依然可以正常工作：



//对于任意无符号数，找大于等于该数的最小pow2,n（也可以当作补全1，记住所有代码不局限一种用途）
//unsigned int v; // 待处理的32位无符号整数
//v += (v == 0)   //特判v==0，确保大于0时可以删
//v--;
//v |= v >> 1;
//v |= v >> 2;
//v |= v >> 4;
//v |= v >> 8;
//v |= v >> 16;
//v++;
//java就用无符号右移>>>


//n & (n-1) 的运用
//n & (n-1) 这个操作在算法中比较常见，作用是消除数字 n 的二进制表示中的最后一个 1。
//消除到最后就会是0了，在一些题里可能会反复用到，
// 比如说让你统计二进制里有几个1
// 比如说让你判断一个数是不是2的指数，那去掉一次就是0的肯定是2的指数

//一个整数得到其对应的负数可以使用(~x + 1) （其实就是算补码）
//n & (~n + 1)可以用于将一个数的二进制位中除了最后一个1之外，其它数位均置为0
//其实就是计组常识




//a ^ a = 0 的运用
//查找只出现一次的元素



