package 模版;

//参考链接：https://labuladong.online/algo/frequency-interview/bitwise-operation/#%E5%AF%B9-2-%E7%9A%84%E5%B9%82%E5%8F%96%E6%A8%A1
// http://graphics.stanford.edu/~seander/bithacks.html

//// 7. 判断两个数是否异号
//int x = -1, y = 2;
//boolean f = ((x ^ y) < 0); // true
//
//        int x = 3, y = 2;
//boolean f = ((x ^ y) < 0); // false


//当模数 m 是 2 的幂时，x % m 等价于 x & (m - 1)
//位运算 & 的效率比 % 高得多，所以这个技巧在性能敏感的场景中非常有用。
//比如说循环数组求模，如果数组长度是pow2,n的，那就可以用这个了
//简单说，& (arr.length - 1) 这个位运算能够替代 % arr.length 的模运算，性能会更好一些。
//那问题来了，现在是不断地 index++，你做到了循环遍历。但如果不断地 index--，还能做到环形数组的效果吗？
//答案是，如果你使用 % 求模的方式，那么当 index 小于 0 之后求模的结果也会出现负数，你需要特殊处理。但通过 & 与运算的方式，index 不会出现负数，依然可以正常工作：



//对于任意无符号数，找大于等于该数的最小pow2,n（也可以当作补全1，记住所有代码不局限一种用途）
//unsigned int v; // 待处理的32位无符号整数
//v += (v == 0)   //特判v==0，确保大于0时可以删
//v--;
//v |= v >> 1;
//v |= v >> 2;
//v |= v >> 4;
//v |= v >> 8;
//v |= v >> 16;
//v++;
//java就用无符号右移>>>


//n & (n-1) 的运用
//n & (n-1) 这个操作在算法中比较常见，作用是消除数字 n 的二进制表示中的最后一个 1。
//消除到最后就会是0了，在一些题里可能会反复用到，
// 比如说让你统计二进制里有几个1
// 比如说让你判断一个数是不是2的指数，那去掉一次就是0的肯定是2的指数

//一个整数得到其对应的负数可以使用(~x + 1) （其实就是算补码）
//n & (~n + 1)可以用于将一个数的二进制位中除了最后一个1之外，其它数位均置为0
//如果这个数是偶数， 则结果是能整除这个偶数的最大的2的幂(即： m = n & -n , 则 n % m = 0, 且 m = 2 ^ k)， 如果这个数是奇数， 则结果必为1
//其实就是计组常识




//a ^ a = 0 的运用
//查找只出现一次的元素

//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。
// 你可以不使用额外空间来实现吗？
//分析：
//这题和上一题的思路略有不同，这题其他数字出现了3次，那么我们如果直接使用位运算异或操作的话无法直接找到结果，就需要巧妙的运用二进制的其他特性：
// 判断整除求余操作。即判断所有数字二进制1的总个数和0的总个数一定有一个不是三的整数倍，如果0不是三的整数倍那么就说明结果的该位二进制数字为0，同理否则为1.

//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
//思路：
//上面的问题处理和理解起来可能比较容易，但是这个问题可能稍微复杂一点，但是这题可以通过特殊的手段转化为上面只出现一次的一个数字问题来解决，当然核心的位运算也是异或^。
//具体思路就是想办法将数组逻辑上一分为二！先异或一遍到最后得到一个数，得到的肯定是a^b(假设两个数值分别为a和b)的值。
// 在看异或^的属性：不同为1，相同为0.也就是说最终这个结果的二进制为1的位置上a和b是不相同的。
// 而我们可以找到这个第一个不同的位，然后将数组中的数分成两份，该位为0的进行异或求解得到其中一个结果a，该位为1的进行异或求解得到另一个结果b。
